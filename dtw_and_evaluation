import pickle
from pyts.metrics import dtw
import matplotlib.pyplot as plt

# https://pyts.readthedocs.io/en/stable/auto_examples/metrics/
# plot_dtw.html#sphx-glr-auto-examples-metrics-plot-dtw-py
# installing pyts:https://pyts.readthedocs.io/en/stable/install.html


def main():
    ########## load the stored data ###########
    dictionary_file = open('dictPickle', 'rb')  # reading mode
    feature_dict = pickle.load(dictionary_file)
    dictionary_file.close()

    keywords = ['273-23-05', '270-09-01', '271-19-02', '272-15-03', '270-17-05', '273-03-04', '270-23-01', '270-17-03', '272-29-08', '275-25-04', '271-04-03', '270-17-02', '274-33-01', '277-23-06', '279-16-08', '270-31-01', '270-01-05', '278-03-04', '276-02-02', '273-09-03', '275-14-06', '272-29-07', '270-16-02', '271-11-04', '270-01-03', '270-23-06', '270-15-01', '276-21-03', '275-04-07', '271-04-08', '277-15-05', '270-27-03', '277-19-04', '273-27-07', '271-16-02', '270-29-02', '279-21-05', '274-24-01', '277-14-03', '274-26-03', '274-06-01', '271-04-07', '273-23-02', '270-18-01', '276-12-01', '270-06-01', '270-14-02', '278-21-09', '271-15-04', '274-12-07', '271-12-01', '278-11-04', '272-20-02', '272-34-05', '271-31-03', '275-05-05', '270-24-08', '274-27-06', '270-08-07', '273-05-02', '275-23-03', '274-14-08', '275-35-01', '272-16-07', '277-09-07', '271-17-09', '277-22-07', '271-30-05', '270-08-02', '270-18-03', '272-19-01', '275-15-04', '270-33-04', '273-04-01', '273-26-01', '272-17-05', '274-25-01', '270-28-02', '270-30-05', '270-27-07', '272-35-02', '271-17-07', '271-05-04', '271-32-03', '270-21-05', '274-26-06', '271-10-02', '272-22-05', '275-27-05', '272-26-02', '279-18-06', '270-25-07', '272-07-02', '274-19-05', '271-05-06', '270-04-08', '270-12-03', '271-10-04', '271-10-08', '274-14-01', '270-08-01', '272-12-01', '277-25-03', '274-10-08', '273-28-01', '276-05-06', '273-31-06']

    valid_pages = get_valid_pages()
    dic = read_transcription(valid_pages)
    entire_dic=read_whole_transcription()

    corresponding_keywords=[]
    indeces = []
    distances = []
    for keyword in keywords:
        sandros_dict, feat_names = get_scores_dict(keyword, feature_dict)
        ### Dear Dona, please put your code here:
        print("hallo dona :)")
        print("###", keyword)
        # main
        keyword=entire_dic[keyword]
        for feature in feat_names:
            mydic = sandros_dict[feature]
            for key in mydic:
                indeces.append(key)
                distances.append(mydic[key])
                corresponding_keywords.append(keyword)
        # now distances however is unsorted--> I want to sort it but without losing the corresponding index in indeces, i.e
        # the two lists must be mixed exactly in the same way
    distances, indeces,corresponding_keywords = (list(t) for t in zip(*sorted(zip(distances, indeces, corresponding_keywords))))
    print(distances,indeces,corresponding_keywords)
    lower_threshold, upper_threshold = find_threshold_range(dic, indeces, distances, corresponding_keywords)

    distance_range = distances[distances.index(lower_threshold):distances.index(upper_threshold) + 1]
    count = distances.index(lower_threshold)
    precisions = []
    recalls = []
    TP,FP, FN=initial_TP_FP_FN_calculation(dic, indeces[:count+1], corresponding_keywords[:count+1])
    print("values",TP, FP, FN)
    precision, recall=precision_recall_calc(TP,FP,FN)
    precisions.append(precision)
    recalls.append(recall)
    for distance in range(len(distance_range)):
        count += 1
        TP,FP,FN = TP_FP_FN_calculation(dic, indeces[count], corresponding_keywords[count], TP,FP, FN)
        print("values2",TP, FP, FN)
        precision, recall=precision_recall_calc(TP,FP,FN)
        precisions.append(precision)
        recalls.append(recall)




    print(precisions, recalls)
    # now I sometimes have more than 1 precision for the same recall value; I only want to keep the first one
    final_precision_list = []
    final_recall_list = []
    index = -1
    for i in recalls:
        index += 1
        if i not in final_recall_list:
            final_recall_list.append(i)
            final_precision_list.append(precisions[index])

    print("final:", final_precision_list, final_recall_list)

    plt.plot(final_recall_list, final_precision_list, marker='o', markersize=3, color="red")
    plt.xlabel("recall")
    plt.ylabel("precision")
    plt.title("Recall-Precision curve/AP")
    plt.show()






def get_scores_dict(keyword, feat_dic):

    ########## calculate DTW ###########
    # get the name of all freatures: (UC, LC, bw_ratio...)
    feat_names = feat_dic[keyword].keys()

    # calculate dtw of all features from a keyword against all words from the
    # "valid"-set
    dtw_scores = {ft: None for ft in feat_names}
    for ft in feat_names:  # UC, LC, bw_ratio...
        dtw_scores[ft] = {word: None for word in feat_dic if word[0] == '3'}
        for word in feat_dic:
            if word[0] == '3':  # only compare against words from the "valid"-set
                dtw_scores[ft][word] = dtw(feat_dic[keyword][ft], feat_dic[word][ft],
                                           method='sakoechiba', options={'window_size': 0.1})

    # order the dicts by increasing values
    for ft in feat_names:
        dtw_scores[ft] = {k: v for k, v in
                          sorted(dtw_scores[ft].items(), key=lambda item: item[1])}

    return dtw_scores, feat_names


def get_valid_pages():
    with open("valid.txt", "r") as validation_set:
        valid_pages=[]
        for line in validation_set:
            valid_pages.append(line.strip('\n'))
    return valid_pages

def read_transcription(valid_pages):
    with open("transcription.txt", "r") as all_words:
        dic={}
        for line in all_words:
            if line[0:3] in valid_pages:
                index=line[0:9] #index has always same length=9
                word=line[10:].rstrip("\n")
                dic[index]=word
    return dic

def read_whole_transcription():
    with open("transcription.txt", "r") as all_words:
        dic={}
        for line in all_words:
            index=line[0:9] #index has always same length=9
            word=line[10:].rstrip("\n")
            dic[index]=word
    return dic

def initial_TP_FP_FN_calculation(all_words_dic, result_indeces, keywords):
    TP=0
    FP=0
    FN=0
    nr_of_features=6
    for key in all_words_dic:
        if all_words_dic[key] in keywords:
            FN+=nr_of_features #nr of keywords to find
    for key in result_indeces:
        index=result_indeces.index(key)
        if all_words_dic[key]==keywords[index]:
            TP+=1
            FN-=1
        else:
            FP+=1
    return (TP, FP, FN)

def TP_FP_FN_calculation(all_words_dic, result_index, keyword, TP, FP, FN):
    if all_words_dic[result_index] == keyword:
        TP += 1
        FN-=1
    else:
        FP += 1
    return (TP, FP, FN)

def precision_recall_calc(TP, FP, FN):
    if TP == 0:  # necessary to avoid division by zero in recall calculation; it might be that the searched keyword is not
        # in the validation set
        precision = 1
        recall = 0
    else:
        precision = TP / (TP + FP)
        recall = TP / (TP + FN)
        print("recall",recall)
    return (precision, recall)


def find_threshold_range(all_words_dic, result_indeces, distances, keywords):
    # threshold so dass keine FP gibt bis so dass es keine FN gibt
    count = -1
    first_right=False
    lower_threshold=distances[0]
    for index in result_indeces:
        count += 1
        if all_words_dic[index] == keywords[count]:
            first_right=True
            lower_threshold = distances[count] #threshold to achieve 100% precision
        elif first_right==False: #we have to start at the first match
            lower_threshold=distances[count]
        else:
            break
    count=-1
    upper_threshold = distances[count]
    for index in result_indeces[::-1]:
        if all_words_dic[index]!=keywords[count] and count!=-len(distances):
            upper_threshold=distances[count-1] #threshold to achieve 100% recall
            count-=1
        else:
            break
    return (lower_threshold, upper_threshold)

if __name__ == "__main__":
    main()
